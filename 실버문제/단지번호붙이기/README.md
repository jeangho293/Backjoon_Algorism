# 풀이 :notebook:

   문제 링크 : https://www.acmicpc.net/problem/2667
   
   난이도 : __실버 1__
## 요점
- 모든 영역에 대한 `완전 탐색`과 `BFS` 또는 `DFS`를 활용한 풀이

- `DFS` 또는 `BFS`를 진행하는 도중 총 몇개의 칸 수를 지나왔는지를 계산한다.
    - `path` 리스트를 활용하여 풀이하였음

    
## 풀이
1. 이미 `0`과 `1`로 `maps`가 구성되어 있으므로 따로 `visited`에 관한 리스트를 구성하지 않음

2. `moving_xy = [(1, 0), (-1, 0), (0, 1), (0, -1)]      # 상하좌우에 대한 좌표이동`
    - 좌표에 대한 풀이일 경우 대부분이 상하좌우 이동을 필요로 한다.

3. 모든 x, y 좌표에 대해 `BFS` 또는 `DFS`를 실행해야하는 __완전 탐색__
    ```
    for x in range(n):
        for y in range(n):
            ....
   ```

4. `if maps[x][y]:      # 한번도 방문하지 않은 장소`
    - 이미 방문한 좌표라면 22 line : `maps[moved_x][moved_y]`를 통해 방문한 좌표로 저장된다. 즉, 이 경우에는 `새로운 영역`이 시작된다는 의미.
    - 그러므로 `result += 1   # 새로운 영역이 추가되었다.`

5. 현재의 영역에서 방문한 칸을 저장하는 `path`
    ```
    while queue:
        path.append([queue[0]])         # 지나온 경로 저장
            ...        
      ```
      - __현재의 영역__ 에서 __지나온 경로__ 를 저장한다. 나중에 `len(path)`로 갯수를 구한다.
      
## 틀렸던 부분
- `path`를 통해 현재 영역에서 지나온 경로를 저장하는 부분이 꼬였다. `cnt += 1`과 같이 간단하게 구현하려 했으나 지나온 경로가 딱 `1`개인 경우 오류가 발생